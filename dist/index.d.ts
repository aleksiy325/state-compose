// Generated by dts-bundle-generator v9.2.4

export type Notify<T> = (value: T) => void;
export type NotifyKey<K, V> = (key: K, value: V) => void;
export type Get<T> = () => [
	T,
	boolean
];
export interface ReadableNode<T> {
	get: Get<T>;
	subscribe: (notify: Notify<T>, skipInitialNotify?: boolean) => void;
	edge<OV>(transformFunc: (input: T, isEqual?: (a: OV, b: OV) => boolean) => OV): ReadableAnyNode<OV>;
}
export interface WritableNode<T> {
	set: (value: T) => boolean;
	setDefer: (value: T) => Get<T>;
	action: <Args extends any[]>(name: string, transitionFunc: (...args: Args) => T) => (...args: Args) => boolean;
	dependentAction<U, Args extends any[]>(name: string, read: ReadableNode<U>, transitionFunc: (read: U, ...args: Args) => T): (...args: Args) => boolean;
	selfAction<Args extends any[]>(name: string, transitionFunc: (read: T, ...args: Args) => T): (...args: Args) => boolean;
}
export type ReadableAnyNode<T> = [
	T
] extends ReadonlyMap<infer K, infer V> ? ReadableMapNode<K, V> : [
	T
] extends [
	object
] ? ReadableCompositeNode<T> : ReadableNode<T>;
export type WritableAnyNode<T> = [
	T
] extends ReadonlyMap<infer K, infer V> ? WritableMapNode<K, V> : [
	T
] extends [
	object
] ? WritableCompositeNode<T> : WritableNode<T>;
export type AnyNode<T> = [
	T
] extends ReadonlyMap<infer K, infer V> ? MapNode<K, V> : [
	T
] extends [
	object
] ? CompositeNode<T> : StateNode<T>;
export interface StateNode<T> extends ReadableNode<T>, WritableNode<T> {
}
export type ReadableCompositeNodeValues<T> = {
	readonly [P in keyof T]: ReadableAnyNode<T[P]>;
};
export type WritableCompositeNodeValues<T> = {
	[P in keyof T]: WritableAnyNode<T[P]>;
};
export type CompositeNodeValues<T> = {
	[P in keyof T]: AnyNode<T[P]>;
};
export interface ReadableCompositeNode<T> extends ReadableNode<T> {
	decompose(): ReadableCompositeNodeValues<T>;
}
export interface WritableCompositeNode<T> extends WritableNode<T> {
	decompose(): WritableCompositeNodeValues<T>;
}
export interface CompositeNode<T> extends ReadableCompositeNode<T>, WritableCompositeNode<T>, StateNode<T> {
	decompose(): CompositeNodeValues<T>;
}
export interface WritableMapNode<K, V> extends WritableNode<ReadonlyMap<K, V>> {
	setKey: (key: K, value: V) => boolean;
	setKeyDefer: (key: K, value: V) => Get<V>;
}
export interface ReadableMapNode<K, V> extends ReadableNode<ReadonlyMap<K, V>> {
	getKey: (key: K) => [
		V,
		boolean
	];
	getKeyNode: (key: K) => AnyNode<V>;
	subscribeKey: (key: K, notify: Notify<V>, skipInitialNotify?: boolean) => void;
	subscribeKeys: (notify: NotifyKey<K, V>, skipInitialNotify?: boolean) => void;
	decompose(): Map<K, ReadableNode<V>>;
	defaultFactory: (key: K) => V;
}
export interface MapNode<K, V> extends WritableMapNode<K, V>, ReadableMapNode<K, V>, StateNode<ReadonlyMap<K, V>> {
}
export interface Shallow<T> {
	value: T;
	isEqual: (previous: T, current: T) => boolean;
	type: "shallow";
}
declare function makeShallow<T>(value: T, isEqual?: (previous: T, current: T) => boolean): Shallow<T>;
declare function node<T>(initValue: T, isEqual?: (a: T, b: T) => boolean): StateNode<T>;
declare const undefnode: StateNode<undefined>;
declare function composeRead<T extends object>(inputNodes: ReadableCompositeNodeValues<T>): ReadableCompositeNode<T>;
declare function compose<T extends object>(inputNodes: CompositeNodeValues<T>): CompositeNode<T>;
declare function compositeNode<T extends object>(initialValue: T): CompositeNode<T>;
declare function mapNode<K, V>(defaultFactory: (key: K) => V, initialValue?: ReadonlyMap<K, V>): MapNode<K, V>;
declare function makeDeepNode<T>(initVal: T | Shallow<T>): AnyNode<T>;
declare function edge<IV, OV>(read: ReadableNode<IV>, transformFunc: (input: IV) => OV, isEqual?: (a: OV, b: OV) => boolean): ReadableAnyNode<OV>;
declare function makeSelector<IV, OV, Args extends any[]>(read: ReadableNode<IV>, transformFunc: (input: IV, ...args: Args) => OV): (...args: Args) => OV;
declare function selfEdge<T, IV>(init: T, read: ReadableNode<IV>, // TODO: make readable only once compose is fixed.
transformFunc: (v: {
	self: T;
	read: IV;
}) => T): AnyNode<T>;
declare function mapToMapEdge<K, IV, OV, RV>(readMap: ReadableMapNode<K, IV>, read: ReadableNode<RV>, transformFunc: (key: K, value: IV, read: RV) => [
	K,
	OV
]): ReadableMapNode<K, OV>;
declare function mapEdge<IV, OK, OV>(read: ReadableNode<IV>, keyUpdateFunc: (read: IV) => [
	OK,
	OV
][], defaultFactory: (key: OK) => OV): ReadableMapNode<OK, OV>;
declare function mapKeyEdge<K, V>(read: ReadableMapNode<K, V>, key: K): ReadableNode<V | undefined>;
declare function action<T, Args extends any[]>(name: string, mutate: WritableNode<T>, transitionFunc: (...args: Args) => T): (...args: Args) => boolean;
declare function dependentAction<T, U, Args extends any[]>(name: string, mutate: WritableNode<T>, read: ReadableNode<U>, transitionFunc: (read: U, ...args: Args) => T): (...args: Args) => boolean;
declare function selfAction<T, Args extends any[]>(name: string, readMutate: StateNode<T>, transitionFunc: (read: T, ...args: Args) => T): (...args: Args) => boolean;
declare const classMap: (element: HTMLElement, values: {
	[key: string]: ReadableNode<boolean | undefined>;
}) => void;
declare const style: (element: HTMLElement, values: {
	[key: string]: ReadableNode<string | undefined>;
}) => void;
declare const text: (element: HTMLElement, value: ReadableNode<string | undefined>) => void;
declare const show: (element: HTMLElement, value: ReadableNode<boolean | undefined>) => void;
declare const arrayRange: (start: number, stop: number, step?: number) => number[];

declare namespace graphState {
	export { AnyNode, CompositeNode, Get, MapNode, Notify, NotifyKey, ReadableAnyNode, ReadableCompositeNode, ReadableMapNode, ReadableNode, Shallow, StateNode, WritableAnyNode, WritableCompositeNode, WritableMapNode, WritableNode, action, compose, composeRead, compositeNode, dependentAction, edge, makeDeepNode, makeSelector, makeShallow, mapEdge, mapKeyEdge, mapNode, mapToMapEdge, node, selfAction, selfEdge, undefnode };
}
declare namespace graphUtil {
	export { arrayRange };
}
declare namespace graphRender {
	export { classMap, show, style, text };
}

export {
	graphRender,
	graphState,
	graphUtil,
};

export {};
